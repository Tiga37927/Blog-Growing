---
title: 小tip
tags:
  - 前端小知识
categories:
  - 前端
  - TIP

date: 2017-08-28 23:36:45
---

2018-1-16

清除浮动：

* 清除浮动并不是让浮动元素回到文档流

* 清除浮动只会改变元素自身的位置，并且只针对排在该元素前面的元素。目的是让自己的左边或者右边没有浮动元素

* 高度坍塌：当没有指定高度的父元素中的子元素全部浮动时，父元素中内部高度因为是普通流中的块元素撑起来的，所以这个时候父元素的高度会变成0或者会有部分浮动元素的位置超出父元素的高度之外

  ``` html
  解决方案：使用after伪元素
  ：after {
  	content: '.';
  	display: block;
  	height: 0;
  	visibility: hidden;
  	clear: both;
  }
  原理是在div的子元素最末尾添加一个元素，如果该元素能够在位于div内部的元素垢面，并且没有浮动，那么最外层div的高度就会重新获取
  ```


数据结构：

​	一、栈（stack）数据结构

​	先进后出，后进先出

​	二、堆（heap）数据结构

​	树状结构，类似key-value

​	三、队列（queue）数据结构

​	先进先出，常见时间循环机制

js执行上下文：执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。js的作用域分一下三种情况：

* 全局环境：js代码运行之后会首先进入这个环境
* 函数环境：当函数被调用执行时，会进入当前函数中执行代码
* eval（不建议使用，可忽略）

js的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，js的基础数据类型会保存在变量对象之中，基础数据类型（undefined、Null、Boolean、String、Number）

因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。

this的指向，是在函数被调用的时候确定的

在函数执行过程中，this一旦被确定，就不可更改了

如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined

“表达式”是一个单纯的运算过程，总是有返回值；“语句”是执行某种操作，没有返回值

### 纯函数

相同的输入总会得到相同的输出，并且不会产生副作用的函数

### new

```javascript
function New(func) {
  var res = {};
  if(func.prototype !== null) {
    res.__proto__ = func.prototype;
  }

  var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));

  if((typeof ret === "object" || typeof ret === "function") && ret !== null) {
    return ret;
  }

  return res;
}
```

new 执行过程：

* 声明一个中间对象
* 将该中间对象的原型指向构造函数的原型
* 将构造函数的this，指向该中间对象
* 返回中间对象



